<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 10: Testing Strategies - Engineering Academy</title>
    <link rel="stylesheet" href="../../../css/styles.css">
    <link rel="stylesheet" href="../../../css/course-styles/course.css">
</head>
<body>
    <header class="main-header">
        <nav class="navbar">
            <div class="container">
                <div class="logo">
                    <h1><a href="../../../index.html" style="color: inherit; text-decoration: none;">üéì Engineering Academy</a></h1>
                </div>
                <ul class="nav-menu">
                    <li><a href="../../../index.html">Home</a></li>
                    <li><a href="../../../index.html#courses">Courses</a></li>
                    <li><a href="../index.html">Course Overview</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <section class="course-header">
        <div class="container">
            <h1>üíª Software Engineering</h1>
            <p>Lesson 10: Testing Strategies</p>
        </div>
    </section>

    <div class="course-container">
        <aside class="course-sidebar">
            <h3>Course Modules</h3>
            <ul class="lesson-list">
                <li><a href="../index.html"><span class="lesson-number">üìö</span>Course Overview</a></li>
                <li><a href="01-introduction.html" class="completed"><span class="lesson-number">1</span>Introduction to SE</a></li>
                <li><a href="02-sdlc.html" class="completed"><span class="lesson-number">2</span>SDLC & Methodologies</a></li>
                <li><a href="03-requirements-engineering.html" class="completed"><span class="lesson-number">3</span>Requirements Engineering</a></li>
                <li><a href="04-creational-patterns.html" class="completed"><span class="lesson-number">4</span>Creational Patterns</a></li>
                <li><a href="05-structural-patterns.html" class="completed"><span class="lesson-number">5</span>Structural Patterns</a></li>
                <li><a href="06-behavioral-patterns.html" class="completed"><span class="lesson-number">6</span>Behavioral Patterns</a></li>
                <li><a href="07-architecture.html" class="completed"><span class="lesson-number">7</span>System Architecture</a></li>
                <li><a href="08-solid-principles.html" class="completed"><span class="lesson-number">8</span>SOLID Principles</a></li>
                <li><a href="09-code-quality.html" class="completed"><span class="lesson-number">9</span>Code Quality</a></li>
                <li><a href="10-testing.html" class="active"><span class="lesson-number">10</span>Testing Strategies</a></li>
                <li class="disabled"><span class="lesson-number">11</span>Version Control <span style="opacity: 0.5;">(Coming Soon)</span></li>
                <li class="disabled"><span class="lesson-number">12</span>Agile & DevOps <span style="opacity: 0.5;">(Coming Soon)</span></li>
            </ul>
        </aside>

        <main class="course-content">
            <h2>Testing Strategies</h2>
            <p class="intro">Master the art of software testing from unit tests to integration tests, learn Test-Driven Development, and understand testing frameworks and best practices.</p>

            <div class="content-section">
                <h3>1. Introduction to Software Testing</h3>
                
                <p>Software testing is the process of evaluating software to find differences between expected and actual behavior. Testing helps ensure quality, reliability, and correctness.</p>

                <div class="info-box">
                    <strong>Why Testing Matters:</strong>
                    <ul>
                        <li><strong>Quality Assurance:</strong> Catch bugs before production</li>
                        <li><strong>Confidence:</strong> Refactor and add features safely</li>
                        <li><strong>Documentation:</strong> Tests show how code should be used</li>
                        <li><strong>Design Feedback:</strong> Hard-to-test code indicates design problems</li>
                        <li><strong>Regression Prevention:</strong> Ensure fixes don't break existing functionality</li>
                    </ul>
                </div>

                <p><strong>Testing Pyramid:</strong> Write more unit tests, fewer integration tests, and even fewer end-to-end tests.</p>

                <div class="example-box">
                    <pre><code>        /\
       /  \      E2E Tests (Few)
      /____\     - Slow, expensive
     /      \    - Test entire system
    /  Inte  \   Integration Tests (Some)
   /  gration\  - Test component interactions
  /____________\ 
 /              \ Unit Tests (Many)
/    Unit Tests  \ - Fast, cheap
/________________\ - Test individual units</code></pre>
                </div>
            </div>

            <div class="content-section">
                <h3>2. Test Levels</h3>
                
                <h4>2.1 Unit Tests</h4>
                <p>Test individual units (functions, methods, classes) in isolation.</p>

                <div class="example-box">
                    <strong>Unit Test Example (Jest)</strong>
                    <pre><code>// calculator.ts
export class Calculator {
  add(a: number, b: number): number {
    return a + b;
  }

  subtract(a: number, b: number): number {
    return a - b;
  }

  multiply(a: number, b: number): number {
    return a * b;
  }

  divide(a: number, b: number): number {
    if (b === 0) {
      throw new Error('Division by zero');
    }
    return a / b;
  }
}

// calculator.test.ts
import { Calculator } from './calculator';

describe('Calculator', () => {
  let calculator: Calculator;

  beforeEach(() => {
    calculator = new Calculator();
  });

  describe('add', () => {
    it('should add two positive numbers', () => {
      expect(calculator.add(2, 3)).toBe(5);
    });

    it('should add negative numbers', () => {
      expect(calculator.add(-2, -3)).toBe(-5);
    });

    it('should add zero', () => {
      expect(calculator.add(5, 0)).toBe(5);
    });
  });

  describe('subtract', () => {
    it('should subtract two numbers', () => {
      expect(calculator.subtract(5, 3)).toBe(2);
    });

    it('should handle negative results', () => {
      expect(calculator.subtract(3, 5)).toBe(-2);
    });
  });

  describe('multiply', () => {
    it('should multiply two numbers', () => {
      expect(calculator.multiply(4, 5)).toBe(20);
    });

    it('should handle multiplication by zero', () => {
      expect(calculator.multiply(5, 0)).toBe(0);
    });
  });

  describe('divide', () => {
    it('should divide two numbers', () => {
      expect(calculator.divide(10, 2)).toBe(5);
    });

    it('should handle decimal results', () => {
      expect(calculator.divide(5, 2)).toBe(2.5);
    });

    it('should throw error when dividing by zero', () => {
      expect(() => calculator.divide(5, 0)).toThrow('Division by zero');
    });
  });
});</code></pre>
                </div>

                <h4>2.2 Integration Tests</h4>
                <p>Test how multiple units work together.</p>

                <div class="example-box">
                    <strong>Integration Test Example</strong>
                    <pre><code>// userService.ts
import { UserRepository } from './userRepository';
import { EmailService } from './emailService';

export class UserService {
  constructor(
    private repository: UserRepository,
    private emailService: EmailService
  ) {}

  async registerUser(name: string, email: string): Promise<User> {
    // Validate
    if (!email.includes('@')) {
      throw new Error('Invalid email');
    }

    // Create user
    const user: User = {
      id: Date.now().toString(),
      name,
      email,
      createdAt: new Date()
    };

    // Save to database
    await this.repository.save(user);

    // Send welcome email
    await this.emailService.sendWelcomeEmail(email, name);

    return user;
  }
}

// userService.integration.test.ts
import { UserService } from './userService';
import { UserRepository } from './userRepository';
import { EmailService } from './emailService';

describe('UserService Integration Tests', () => {
  let userService: UserService;
  let repository: UserRepository;
  let emailService: EmailService;

  beforeEach(() => {
    // Use real implementations or test doubles
    repository = new UserRepository();
    emailService = new EmailService();
    userService = new UserService(repository, emailService);
  });

  it('should register user and send welcome email', async () => {
    const user = await userService.registerUser('Alice', 'alice@example.com');

    // Verify user was saved
    const savedUser = await repository.findById(user.id);
    expect(savedUser).toBeDefined();
    expect(savedUser?.name).toBe('Alice');

    // Verify email was sent
    const sentEmails = emailService.getSentEmails();
    expect(sentEmails).toHaveLength(1);
    expect(sentEmails[0].to).toBe('alice@example.com');
  });

  it('should reject invalid email', async () => {
    await expect(
      userService.registerUser('Bob', 'invalid-email')
    ).rejects.toThrow('Invalid email');
  });
});</code></pre>
                </div>

                <h4>2.3 System/E2E Tests</h4>
                <p>Test the entire system from user's perspective.</p>

                <div class="example-box">
                    <strong>E2E Test Example (Playwright)</strong>
                    <pre><code>// e2e/login.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Login Flow', () => {
  test('should login successfully with valid credentials', async ({ page }) => {
    // Navigate to login page
    await page.goto('http://localhost:3000/login');

    // Fill in credentials
    await page.fill('[data-testid="email-input"]', 'user@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');

    // Click login button
    await page.click('[data-testid="login-button"]');

    // Verify redirect to dashboard
    await expect(page).toHaveURL('http://localhost:3000/dashboard');

    // Verify user is logged in
    await expect(page.locator('[data-testid="user-menu"]')).toContainText('user@example.com');
  });

  test('should show error with invalid credentials', async ({ page }) => {
    await page.goto('http://localhost:3000/login');

    await page.fill('[data-testid="email-input"]', 'wrong@example.com');
    await page.fill('[data-testid="password-input"]', 'wrongpassword');
    await page.click('[data-testid="login-button"]');

    // Verify error message
    await expect(page.locator('[data-testid="error-message"]'))
      .toContainText('Invalid credentials');

    // Verify still on login page
    await expect(page).toHaveURL('http://localhost:3000/login');
  });

  test('should validate email format', async ({ page }) => {
    await page.goto('http://localhost:3000/login');

    await page.fill('[data-testid="email-input"]', 'invalid-email');
    await page.fill('[data-testid="password-input"]', 'password123');
    await page.click('[data-testid="login-button"]');

    await expect(page.locator('[data-testid="email-error"]'))
      .toContainText('Please enter a valid email');
  });
});</code></pre>
                </div>

                <h4>2.4 Acceptance Tests</h4>
                <p>Test against user requirements and acceptance criteria.</p>

                <div class="example-box">
                    <strong>Acceptance Test Example (Cucumber/Gherkin)</strong>
                    <pre><code>Feature: Shopping Cart
  As a customer
  I want to add products to my cart
  So that I can purchase multiple items

  Scenario: Add single item to empty cart
    Given I am on the product page for "Laptop"
    And the product price is "$1200"
    When I click "Add to Cart"
    Then I should see "1 item" in my cart
    And the cart total should be "$1200"

  Scenario: Add multiple items to cart
    Given I have "Laptop" in my cart
    When I add "Mouse" to my cart
    And I add "Keyboard" to my cart
    Then I should see "3 items" in my cart

  Scenario: Remove item from cart
    Given I have "Laptop" in my cart
    And I have "Mouse" in my cart
    When I remove "Mouse" from cart
    Then I should see "1 item" in my cart
    And "Mouse" should not be in my cart</code></pre>
                </div>
            </div>

            <div class="content-section">
                <h3>3. Test-Driven Development (TDD)</h3>
                
                <p>TDD is a development approach where you write tests before writing code.</p>

                <div class="info-box">
                    <strong>TDD Cycle (Red-Green-Refactor):</strong>
                    <ol>
                        <li><strong>üî¥ Red:</strong> Write a failing test</li>
                        <li><strong>üü¢ Green:</strong> Write minimal code to make test pass</li>
                        <li><strong>üîµ Refactor:</strong> Improve code while keeping tests green</li>
                        <li>Repeat</li>
                    </ol>
                </div>

                <div class="example-box">
                    <strong>TDD Example: String Calculator</strong>
                    <pre><code>// Requirement: Create a string calculator with add method
// add("") returns 0
// add("1") returns 1
// add("1,2") returns 3

// Step 1: RED - Write failing test
describe('StringCalculator', () => {
  it('should return 0 for empty string', () => {
    const calculator = new StringCalculator();
    expect(calculator.add("")).toBe(0);
  });
});

// Step 2: GREEN - Write minimal code to pass
class StringCalculator {
  add(numbers: string): number {
    return 0;  // Simplest implementation
  }
}

// Step 1: RED - Add another test
it('should return the number for single number', () => {
  const calculator = new StringCalculator();
  expect(calculator.add("5")).toBe(5);
});

// Step 2: GREEN - Implement
class StringCalculator {
  add(numbers: string): number {
    if (numbers === "") return 0;
    return parseInt(numbers);
  }
}

// Step 1: RED - Add test for two numbers
it('should return sum for two numbers', () => {
  const calculator = new StringCalculator();
  expect(calculator.add("1,2")).toBe(3);
});

// Step 2: GREEN - Implement
class StringCalculator {
  add(numbers: string): number {
    if (numbers === "") return 0;
    
    const nums = numbers.split(',');
    return nums.reduce((sum, n) => sum + parseInt(n), 0);
  }
}

// Step 3: REFACTOR - Clean up
class StringCalculator {
  add(numbers: string): number {
    if (this.isEmpty(numbers)) return 0;
    
    return this.parseNumbers(numbers)
      .reduce((sum, num) => sum + num, 0);
  }

  private isEmpty(numbers: string): boolean {
    return numbers === "";
  }

  private parseNumbers(numbers: string): number[] {
    return numbers.split(',').map(n => parseInt(n));
  }
}

// Continue with more tests...
it('should handle any amount of numbers', () => {
  const calculator = new StringCalculator();
  expect(calculator.add("1,2,3,4,5")).toBe(15);
});

it('should handle newlines as delimiters', () => {
  const calculator = new StringCalculator();
  expect(calculator.add("1\n2,3")).toBe(6);
});</code></pre>
                </div>

                <div class="info-box">
                    <strong>Benefits of TDD:</strong>
                    <ul>
                        <li>Forces you to think about requirements first</li>
                        <li>Ensures code is testable by design</li>
                        <li>Provides immediate feedback</li>
                        <li>Creates comprehensive test suite</li>
                        <li>Reduces debugging time</li>
                        <li>Encourages simple designs</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <h3>4. Test Coverage</h3>
                
                <p>Test coverage measures how much of your code is executed during testing.</p>

                <div class="info-box">
                    <strong>Coverage Metrics:</strong>
                    <ul>
                        <li><strong>Line Coverage:</strong> % of lines executed</li>
                        <li><strong>Branch Coverage:</strong> % of decision branches taken</li>
                        <li><strong>Function Coverage:</strong> % of functions called</li>
                        <li><strong>Statement Coverage:</strong> % of statements executed</li>
                    </ul>
                </div>

                <div class="example-box">
                    <strong>Coverage Example</strong>
                    <pre><code>// Function to test
function getDiscount(customer: Customer, amount: number): number {
  if (customer.isPremium) {                    // Branch 1
    if (amount > 1000) {                       // Branch 2
      return 0.20;  // 20% discount
    } else {
      return 0.10;  // 10% discount
    }
  } else {
    if (amount > 500) {                        // Branch 3
      return 0.05;  // 5% discount
    }
  }
  return 0;
}

// Tests
describe('getDiscount', () => {
  // Test 1: Covers premium customer with amount > 1000
  it('should give 20% discount to premium customer with large order', () => {
    const customer = { isPremium: true };
    expect(getDiscount(customer, 1500)).toBe(0.20);
  });
  // Coverage: Lines 2,3,4 | Branches: 1(true), 2(true)

  // Test 2: Covers premium customer with amount <= 1000
  it('should give 10% discount to premium customer with small order', () => {
    const customer = { isPremium: true };
    expect(getDiscount(customer, 500)).toBe(0.10);
  });
  // Coverage: Lines 2,3,6 | Branches: 1(true), 2(false)

  // Test 3: Covers regular customer with amount > 500
  it('should give 5% discount to regular customer with medium order', () => {
    const customer = { isPremium: false };
    expect(getDiscount(customer, 700)).toBe(0.05);
  });
  // Coverage: Lines 2,9,10 | Branches: 1(false), 3(true)

  // Test 4: Covers regular customer with amount <= 500
  it('should give no discount to regular customer with small order', () => {
    const customer = { isPremium: false };
    expect(getDiscount(customer, 100)).toBe(0);
  });
  // Coverage: Lines 2,9,13 | Branches: 1(false), 3(false)
});

// Full coverage achieved: 100% lines, 100% branches

// Run coverage with Jest:
// npm test -- --coverage

// Output:
// File         | % Stmts | % Branch | % Funcs | % Lines
// discount.ts  |   100   |   100    |   100   |   100</code></pre>
                </div>

                <p><strong>Coverage Goals:</strong> Aim for 80%+ coverage, but remember: 100% coverage doesn't mean bug-free code. Quality matters more than quantity.</p>
            </div>

            <div class="content-section">
                <h3>5. Mocking and Stubbing</h3>
                
                <p>Test doubles isolate code under test from dependencies.</p>

                <h4>5.1 Mocks</h4>
                <p>Objects that verify interactions (method calls, arguments).</p>

                <div class="example-box">
                    <strong>Mock Example</strong>
                    <pre><code>// Service to test
class OrderService {
  constructor(
    private paymentGateway: PaymentGateway,
    private emailService: EmailService
  ) {}

  async placeOrder(order: Order): Promise<void> {
    // Process payment
    await this.paymentGateway.charge(order.total);
    
    // Send confirmation
    await this.emailService.send(
      order.customerEmail,
      'Order Confirmation',
      `Your order ${order.id} is confirmed`
    );
  }
}

// Test with mocks
describe('OrderService', () => {
  it('should charge payment and send email', async () => {
    // Create mocks
    const paymentGateway = {
      charge: jest.fn().mockResolvedValue({ success: true })
    };
    
    const emailService = {
      send: jest.fn().mockResolvedValue(true)
    };

    const orderService = new OrderService(
      paymentGateway as any,
      emailService as any
    );

    const order: Order = {
      id: 'ORD-123',
      total: 100,
      customerEmail: 'user@example.com'
    };

    await orderService.placeOrder(order);

    // Verify interactions
    expect(paymentGateway.charge).toHaveBeenCalledWith(100);
    expect(paymentGateway.charge).toHaveBeenCalledTimes(1);

    expect(emailService.send).toHaveBeenCalledWith(
      'user@example.com',
      'Order Confirmation',
      'Your order ORD-123 is confirmed'
    );
    expect(emailService.send).toHaveBeenCalledTimes(1);
  });
});</code></pre>
                </div>

                <h4>5.2 Stubs</h4>
                <p>Objects that provide predefined responses.</p>

                <div class="example-box">
                    <strong>Stub Example</strong>
                    <pre><code>// Service to test
class UserService {
  constructor(private apiClient: ApiClient) {}

  async getUserProfile(userId: string): Promise<UserProfile> {
    const data = await this.apiClient.get(`/users/${userId}`);
    
    return {
      name: data.name,
      email: data.email,
      joinDate: new Date(data.created_at)
    };
  }
}

// Test with stub
describe('UserService', () => {
  it('should fetch and transform user profile', async () => {
    // Create stub that returns predefined data
    const apiClientStub = {
      get: jest.fn().mockResolvedValue({
        name: 'Alice',
        email: 'alice@example.com',
        created_at: '2024-01-15'
      })
    };

    const userService = new UserService(apiClientStub as any);
    const profile = await userService.getUserProfile('123');

    expect(profile).toEqual({
      name: 'Alice',
      email: 'alice@example.com',
      joinDate: new Date('2024-01-15')
    });

    expect(apiClientStub.get).toHaveBeenCalledWith('/users/123');
  });

  it('should handle API errors', async () => {
    // Stub that throws error
    const apiClientStub = {
      get: jest.fn().mockRejectedValue(new Error('Network error'))
    };

    const userService = new UserService(apiClientStub as any);

    await expect(userService.getUserProfile('123'))
      .rejects.toThrow('Network error');
  });
});</code></pre>
                </div>

                <h4>5.3 Spies</h4>
                <p>Wrap real objects to track interactions.</p>

                <div class="example-box">
                    <strong>Spy Example</strong>
                    <pre><code>// Real implementation
class Logger {
  log(message: string): void {
    console.log(`[LOG] ${message}`);
  }

  error(message: string): void {
    console.error(`[ERROR] ${message}`);
  }
}

class UserRegistration {
  constructor(private logger: Logger) {}

  register(email: string): User {
    this.logger.log(`Registering user: ${email}`);
    
    const user = { id: '123', email };
    
    this.logger.log(`User ${email} registered successfully`);
    
    return user;
  }
}

// Test with spy
describe('UserRegistration', () => {
  it('should log registration steps', () => {
    const logger = new Logger();
    const logSpy = jest.spyOn(logger, 'log');  // Spy on real object

    const registration = new UserRegistration(logger);
    const user = registration.register('test@example.com');

    // Verify spy was called
    expect(logSpy).toHaveBeenCalledTimes(2);
    expect(logSpy).toHaveBeenNthCalledWith(1, 'Registering user: test@example.com');
    expect(logSpy).toHaveBeenNthCalledWith(2, 'User test@example.com registered successfully');

    // Real implementation still works
    expect(user).toEqual({ id: '123', email: 'test@example.com' });

    logSpy.mockRestore();  // Clean up
  });
});</code></pre>
                </div>
            </div>

            <div class="content-section">
                <h3>6. Testing Frameworks</h3>
                
                <h4>6.1 Jest (JavaScript/TypeScript)</h4>
                
                <div class="example-box">
                    <strong>Jest Features</strong>
                    <pre><code>// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverageFrom: ['src/**/*.ts'],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};

// Test with matchers
describe('Array operations', () => {
  test('toBe vs toEqual', () => {
    const obj1 = { name: 'Alice' };
    const obj2 = { name: 'Alice' };
    
    expect(obj1).toEqual(obj2);  // Deep equality ‚úÖ
    expect(obj1).not.toBe(obj2); // Reference equality ‚ùå
  });

  test('array matchers', () => {
    const arr = [1, 2, 3, 4, 5];
    
    expect(arr).toHaveLength(5);
    expect(arr).toContain(3);
    expect(arr).toEqual(expect.arrayContaining([2, 4]));
  });

  test('object matchers', () => {
    const user = { name: 'Bob', age: 30, email: 'bob@example.com' };
    
    expect(user).toHaveProperty('name');
    expect(user).toHaveProperty('age', 30);
    expect(user).toMatchObject({ name: 'Bob' });
  });

  test('async code', async () => {
    const fetchData = () => Promise.resolve('data');
    
    await expect(fetchData()).resolves.toBe('data');
  });

  test('exceptions', () => {
    const throwError = () => { throw new Error('Oops'); };
    
    expect(throwError).toThrow('Oops');
    expect(throwError).toThrow(Error);
  });
});</code></pre>
                </div>

                <h4>6.2 Mocha + Chai (JavaScript)</h4>
                
                <div class="example-box">
                    <pre><code>import { expect } from 'chai';
import { Calculator } from './calculator';

describe('Calculator', () => {
  let calc: Calculator;

  beforeEach(() => {
    calc = new Calculator();
  });

  it('should add numbers', () => {
    expect(calc.add(2, 3)).to.equal(5);
  });

  it('should multiply numbers', () => {
    expect(calc.multiply(4, 5)).to.equal(20);
  });

  it('should handle negative numbers', () => {
    expect(calc.add(-2, -3)).to.equal(-5);
  });
});</code></pre>
                </div>

                <h4>6.3 PyTest (Python)</h4>
                
                <div class="example-box">
                    <pre><code># calculator.py
class Calculator:
    def add(self, a, b):
        return a + b
    
    def divide(self, a, b):
        if b == 0:
            raise ValueError("Division by zero")
        return a / b

# test_calculator.py
import pytest
from calculator import Calculator

@pytest.fixture
def calculator():
    return Calculator()

def test_add(calculator):
    assert calculator.add(2, 3) == 5

def test_divide(calculator):
    assert calculator.divide(10, 2) == 5

def test_divide_by_zero(calculator):
    with pytest.raises(ValueError, match="Division by zero"):
        calculator.divide(10, 0)

@pytest.mark.parametrize("a,b,expected", [
    (2, 3, 5),
    (-1, 1, 0),
    (0, 0, 0),
    (100, 200, 300)
])
def test_add_multiple_cases(calculator, a, b, expected):
    assert calculator.add(a, b) == expected</code></pre>
                </div>
            </div>

            <div class="content-section">
                <h3>7. Automated Testing & CI Integration</h3>
                
                <div class="example-box">
                    <strong>GitHub Actions CI/CD Pipeline</strong>
                    <pre><code># .github/workflows/test.yml
name: Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'

    - name: Install dependencies
      run: npm ci

    - name: Run linter
      run: npm run lint

    - name: Run tests
      run: npm test -- --coverage

    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/coverage-final.json

    - name: Check coverage threshold
      run: |
        COVERAGE=$(cat coverage/coverage-summary.json | jq '.total.lines.pct')
        if (( $(echo "$COVERAGE < 80" | bc -l) )); then
          echo "Coverage $COVERAGE% is below threshold 80%"
          exit 1
        fi</code></pre>
                </div>
            </div>

            <div class="content-section">
                <h3>8. Practice Problems</h3>
                
                <div class="practice-problems">
                    <div class="problem">
                        <h4>Problem 1: Write Tests for Shopping Cart</h4>
                        <p><strong>Task:</strong> Write comprehensive unit tests for a shopping cart class using TDD.</p>
                        <p><strong>Requirements:</strong></p>
                        <ul>
                            <li>Add items to cart</li>
                            <li>Remove items from cart</li>
                            <li>Calculate total</li>
                            <li>Apply discount codes</li>
                            <li>Clear cart</li>
                        </ul>
                        
                        <details>
                            <summary>Show Solution</summary>
                            <pre><code>// Step 1: Write tests first (RED)
describe('ShoppingCart', () => {
  let cart: ShoppingCart;

  beforeEach(() => {
    cart = new ShoppingCart();
  });

  describe('addItem', () => {
    it('should add item to empty cart', () => {
      cart.addItem({ id: '1', name: 'Laptop', price: 1000 }, 1);
      expect(cart.getItemCount()).toBe(1);
    });

    it('should increase quantity if item already exists', () => {
      const item = { id: '1', name: 'Laptop', price: 1000 };
      cart.addItem(item, 1);
      cart.addItem(item, 2);
      expect(cart.getItemCount()).toBe(1);
      expect(cart.getItems()[0].quantity).toBe(3);
    });
  });

  describe('removeItem', () => {
    it('should remove item from cart', () => {
      cart.addItem({ id: '1', name: 'Laptop', price: 1000 }, 1);
      cart.removeItem('1');
      expect(cart.getItemCount()).toBe(0);
    });
  });

  describe('calculateTotal', () => {
    it('should return 0 for empty cart', () => {
      expect(cart.calculateTotal()).toBe(0);
    });

    it('should calculate total for single item', () => {
      cart.addItem({ id: '1', name: 'Mouse', price: 25 }, 2);
      expect(cart.calculateTotal()).toBe(50);
    });

    it('should calculate total for multiple items', () => {
      cart.addItem({ id: '1', name: 'Mouse', price: 25 }, 2);
      cart.addItem({ id: '2', name: 'Keyboard', price: 75 }, 1);
      expect(cart.calculateTotal()).toBe(125);
    });
  });

  describe('applyDiscount', () => {
    it('should apply percentage discount', () => {
      cart.addItem({ id: '1', name: 'Laptop', price: 1000 }, 1);
      cart.applyDiscount('SAVE10', 0.10);
      expect(cart.calculateTotal()).toBe(900);
    });
  });

  describe('clear', () => {
    it('should remove all items', () => {
      cart.addItem({ id: '1', name: 'Mouse', price: 25 }, 2);
      cart.addItem({ id: '2', name: 'Keyboard', price: 75 }, 1);
      cart.clear();
      expect(cart.getItemCount()).toBe(0);
      expect(cart.calculateTotal()).toBe(0);
    });
  });
});

// Step 2: Implement to pass tests (GREEN)
interface Product {
  id: string;
  name: string;
  price: number;
}

interface CartItem {
  product: Product;
  quantity: number;
}

class ShoppingCart {
  private items: Map<string, CartItem> = new Map();
  private discountRate: number = 0;

  addItem(product: Product, quantity: number): void {
    const existing = this.items.get(product.id);
    if (existing) {
      existing.quantity += quantity;
    } else {
      this.items.set(product.id, { product, quantity });
    }
  }

  removeItem(productId: string): void {
    this.items.delete(productId);
  }

  getItemCount(): number {
    return this.items.size;
  }

  getItems(): CartItem[] {
    return Array.from(this.items.values());
  }

  calculateTotal(): number {
    let total = 0;
    for (const item of this.items.values()) {
      total += item.product.price * item.quantity;
    }
    return total * (1 - this.discountRate);
  }

  applyDiscount(code: string, rate: number): void {
    this.discountRate = rate;
  }

  clear(): void {
    this.items.clear();
    this.discountRate = 0;
  }
}</code></pre>
                        </details>
                    </div>
                </div>
            </div>

            <div class="key-takeaways">
                <h3>Key Takeaways</h3>
                <ul>
                    <li><strong>Test Pyramid:</strong> Many unit tests, some integration tests, few E2E tests</li>
                    <li><strong>TDD:</strong> Red-Green-Refactor cycle improves design and ensures testability</li>
                    <li><strong>Coverage:</strong> Aim for 80%+ but focus on quality over quantity</li>
                    <li><strong>Test Doubles:</strong> Use mocks, stubs, and spies to isolate units</li>
                    <li><strong>Frameworks:</strong> Jest, Mocha, PyTest provide powerful testing capabilities</li>
                    <li><strong>Automation:</strong> Integrate tests into CI/CD pipeline</li>
                    <li><strong>Fast Feedback:</strong> Run tests frequently during development</li>
                    <li>Tests are documentation - they show how code should be used</li>
                    <li>Write testable code - if it's hard to test, it's probably poorly designed</li>
                </ul>
            </div>

            <div class="lesson-navigation">
                <a href="09-code-quality.html" class="nav-btn">‚Üê Previous: Code Quality</a>
                <a href="11-version-control.html" class="nav-btn">Next: Version Control ‚Üí</a>
            </div>
        </main>
    </div>

    <script src="../../../js/course.js"></script>
</body>
</html>
