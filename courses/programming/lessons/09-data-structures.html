<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 9: Data Structures - Engineering Academy</title>
    <link rel="stylesheet" href="../../../css/styles.css">
    <link rel="stylesheet" href="../../../css/course-styles/course.css">
</head>
<body>
    <header class="main-header">
        <nav class="navbar">
            <div class="container">
                <div class="logo">
                    <h1><a href="../../../index.html" style="color: inherit; text-decoration: none;">üéì Engineering Academy</a></h1>
                </div>
                <ul class="nav-menu">
                    <li><a href="../../../index.html">Home</a></li>
                    <li><a href="../index.html">Course Overview</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <section class="course-header">
        <div class="container">
            <h1>‚å®Ô∏è Programming</h1>
            <p>Lesson 9: Data Structures</p>
        </div>
    </section>

    <div class="course-container">
        <aside class="course-sidebar">
            <h3>Course Modules</h3>
            <ul class="lesson-list">
                <li><a href="../index.html"><span class="lesson-number">üìö</span>Course Overview</a></li>
                <li><a href="01-programming-fundamentals.html" class="completed"><span class="lesson-number">1</span>Programming Fundamentals</a></li>
                <li><a href="02-python-basics.html" class="completed"><span class="lesson-number">2</span>Python Basics</a></li>
                <li><a href="03-python-advanced.html" class="completed"><span class="lesson-number">3</span>Python Advanced</a></li>
                <li><a href="04-javascript-basics.html" class="completed"><span class="lesson-number">4</span>JavaScript Basics</a></li>
                <li><a href="05-javascript-modern.html" class="completed"><span class="lesson-number">5</span>Modern JavaScript</a></li>
                <li><a href="06-cpp-basics.html" class="completed"><span class="lesson-number">6</span>C++ Basics</a></li>
                <li><a href="07-cpp-advanced.html" class="completed"><span class="lesson-number">7</span>C++ Advanced</a></li>
                <li><a href="08-oop-principles.html" class="completed"><span class="lesson-number">8</span>OOP Principles</a></li>
                <li><a href="09-data-structures.html" class="active"><span class="lesson-number">9</span>Data Structures</a></li>
                <li><a href="10-algorithms.html"><span class="lesson-number">10</span>Algorithms</a></li>
                <li><a href="11-debugging.html"><span class="lesson-number">11</span>Debugging & Testing</a></li>
                <li><a href="12-best-practices.html"><span class="lesson-number">12</span>Best Practices</a></li>
            </ul>
        </aside>

        <main class="course-content">
            <div class="lesson-header">
                <h2>Lesson 9: Data Structures</h2>
                <div class="lesson-meta">
                    <span>üìñ 75 min read</span>
                    <span>üìä Intermediate-Advanced</span>
                </div>
            </div>

            <div class="lesson-content">
                <h3>What are Data Structures?</h3>
                <p>
                    Data structures are specialized formats for organizing, storing, and managing data in a computer. 
                    The choice of data structure significantly impacts program performance - the difference between 
                    a program running in milliseconds versus hours.
                </p>

                <div class="info-box note">
                    <h4>üìå Why Data Structures Matter</h4>
                    <p>
                        "Bad programmers worry about the code. Good programmers worry about data structures and their relationships."
                        <br>- Linus Torvalds
                    </p>
                </div>

                <h3>Time Complexity - Big O Notation</h3>
                <p>
                    Before diving into data structures, understand how we measure their efficiency:
                </p>

                <table>
                    <thead>
                        <tr>
                            <th>Notation</th>
                            <th>Name</th>
                            <th>Example</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>O(1)</td>
                            <td>Constant</td>
                            <td>Array access</td>
                            <td>Same time regardless of size</td>
                        </tr>
                        <tr>
                            <td>O(log n)</td>
                            <td>Logarithmic</td>
                            <td>Binary search</td>
                            <td>Doubles problem size = +1 step</td>
                        </tr>
                        <tr>
                            <td>O(n)</td>
                            <td>Linear</td>
                            <td>Array traversal</td>
                            <td>Time grows with size</td>
                        </tr>
                        <tr>
                            <td>O(n log n)</td>
                            <td>Linearithmic</td>
                            <td>Merge sort</td>
                            <td>Efficient sorting</td>
                        </tr>
                        <tr>
                            <td>O(n¬≤)</td>
                            <td>Quadratic</td>
                            <td>Bubble sort</td>
                            <td>Nested loops</td>
                        </tr>
                        <tr>
                            <td>O(2‚Åø)</td>
                            <td>Exponential</td>
                            <td>Fibonacci recursion</td>
                            <td>Doubles with each +1</td>
                        </tr>
                    </tbody>
                </table>

                <hr style="margin: 2rem 0;">

                <h3>1. Arrays and Lists</h3>
                <p>
                    The most fundamental data structure - a collection of elements stored contiguously in memory.
                </p>

                <h4>Operations & Complexity</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Time Complexity</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td>Access by index</td><td>O(1)</td></tr>
                        <tr><td>Search</td><td>O(n)</td></tr>
                        <tr><td>Insert at end</td><td>O(1) amortized</td></tr>
                        <tr><td>Insert at beginning</td><td>O(n)</td></tr>
                        <tr><td>Delete</td><td>O(n)</td></tr>
                    </tbody>
                </table>

                <h4>Implementation in Python</h4>
                <div class="code-block" data-language="python">
<code><span class="comment"># Dynamic array operations</span>
arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]

<span class="comment"># Access - O(1)</span>
element = arr[<span class="number">2</span>]  <span class="comment"># 3</span>

<span class="comment"># Search - O(n)</span>
<span class="keyword">def</span> <span class="function">linear_search</span>(arr, target):
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="keyword">len</span>(arr)):
        <span class="keyword">if</span> arr[i] == target:
            <span class="keyword">return</span> i
    <span class="keyword">return</span> -<span class="number">1</span>

<span class="comment"># Insert - O(1) at end, O(n) at beginning</span>
arr.append(<span class="number">6</span>)        <span class="comment"># [1,2,3,4,5,6] - O(1)</span>
arr.insert(<span class="number">0</span>, <span class="number">0</span>)    <span class="comment"># [0,1,2,3,4,5,6] - O(n)</span>

<span class="comment"># Delete - O(n)</span>
arr.remove(<span class="number">3</span>)        <span class="comment"># Removes first occurrence</span>
arr.pop()            <span class="comment"># Removes last - O(1)</span>
</code>
                </div>

                <hr style="margin: 2rem 0;">

                <h3>2. Linked Lists</h3>
                <p>
                    A sequence of nodes where each node contains data and a reference to the next node. 
                    Better for frequent insertions/deletions than arrays.
                </p>

                <div class="code-block" data-language="python">
<code><span class="keyword">class</span> <span class="class-name">Node</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, data):
        self.data = data
        self.next = <span class="keyword">None</span>

<span class="keyword">class</span> <span class="class-name">LinkedList</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.head = <span class="keyword">None</span>
    
    <span class="keyword">def</span> <span class="function">append</span>(self, data):
        <span class="string">"""Add node to end - O(n)"""</span>
        new_node = Node(data)
        
        <span class="keyword">if</span> <span class="keyword">not</span> self.head:
            self.head = new_node
            <span class="keyword">return</span>
        
        current = self.head
        <span class="keyword">while</span> current.next:
            current = current.next
        current.next = new_node
    
    <span class="keyword">def</span> <span class="function">prepend</span>(self, data):
        <span class="string">"""Add node to beginning - O(1)"""</span>
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
    
    <span class="keyword">def</span> <span class="function">delete</span>(self, data):
        <span class="string">"""Delete first occurrence - O(n)"""</span>
        <span class="keyword">if</span> <span class="keyword">not</span> self.head:
            <span class="keyword">return</span>
        
        <span class="keyword">if</span> self.head.data == data:
            self.head = self.head.next
            <span class="keyword">return</span>
        
        current = self.head
        <span class="keyword">while</span> current.next:
            <span class="keyword">if</span> current.next.data == data:
                current.next = current.next.next
                <span class="keyword">return</span>
            current = current.next
    
    <span class="keyword">def</span> <span class="function">display</span>(self):
        <span class="string">"""Print all nodes - O(n)"""</span>
        elements = []
        current = self.head
        <span class="keyword">while</span> current:
            elements.append(<span class="keyword">str</span>(current.data))
            current = current.next
        <span class="keyword">print</span>(<span class="string">" -> "</span>.join(elements))

<span class="comment"># Usage</span>
ll = LinkedList()
ll.append(<span class="number">1</span>)
ll.append(<span class="number">2</span>)
ll.append(<span class="number">3</span>)
ll.prepend(<span class="number">0</span>)
ll.display()  <span class="comment"># 0 -> 1 -> 2 -> 3</span>
</code>
                </div>

                <div class="info-box tip">
                    <h4>üí° Arrays vs Linked Lists</h4>
                    <table>
                        <tr>
                            <th>Use Array When:</th>
                            <th>Use Linked List When:</th>
                        </tr>
                        <tr>
                            <td>Need fast random access</td>
                            <td>Frequent insertions/deletions</td>
                        </tr>
                        <tr>
                            <td>Size is known/fixed</td>
                            <td>Size unknown/dynamic</td>
                        </tr>
                        <tr>
                            <td>Memory is contiguous</td>
                            <td>Memory can be scattered</td>
                        </tr>
                    </table>
                </div>

                <hr style="margin: 2rem 0;">

                <h3>3. Stacks</h3>
                <p>
                    LIFO (Last In, First Out) data structure. Like a stack of plates - you add and remove from the top.
                </p>

                <h4>Common Uses:</h4>
                <ul>
                    <li>Function call stack (recursion)</li>
                    <li>Undo functionality</li>
                    <li>Browser back button</li>
                    <li>Expression evaluation</li>
                </ul>

                <div class="code-block" data-language="python">
<code><span class="keyword">class</span> <span class="class-name">Stack</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.items = []
    
    <span class="keyword">def</span> <span class="function">push</span>(self, item):
        <span class="string">"""Add item to top - O(1)"""</span>
        self.items.append(item)
    
    <span class="keyword">def</span> <span class="function">pop</span>(self):
        <span class="string">"""Remove and return top item - O(1)"""</span>
        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():
            <span class="keyword">return</span> self.items.pop()
        <span class="keyword">raise</span> <span class="class-name">IndexError</span>(<span class="string">"Stack is empty"</span>)
    
    <span class="keyword">def</span> <span class="function">peek</span>(self):
        <span class="string">"""View top item without removing - O(1)"""</span>
        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():
            <span class="keyword">return</span> self.items[-<span class="number">1</span>]
        <span class="keyword">return</span> <span class="keyword">None</span>
    
    <span class="keyword">def</span> <span class="function">is_empty</span>(self):
        <span class="keyword">return</span> <span class="keyword">len</span>(self.items) == <span class="number">0</span>
    
    <span class="keyword">def</span> <span class="function">size</span>(self):
        <span class="keyword">return</span> <span class="keyword">len</span>(self.items)

<span class="comment"># Example: Balanced Parentheses Checker</span>
<span class="keyword">def</span> <span class="function">is_balanced</span>(expression):
    stack = Stack()
    pairs = {<span class="string">')'</span>: <span class="string">'('</span>, <span class="string">']'</span>: <span class="string">'['</span>, <span class="string">'}'</span>: <span class="string">'{'</span>}
    
    <span class="keyword">for</span> char <span class="keyword">in</span> expression:
        <span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">'([{'</span>:
            stack.push(char)
        <span class="keyword">elif</span> char <span class="keyword">in</span> <span class="string">')]}'</span>:
            <span class="keyword">if</span> stack.is_empty() <span class="keyword">or</span> stack.pop() != pairs[char]:
                <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">return</span> stack.is_empty()

<span class="keyword">print</span>(is_balanced(<span class="string">"([{}])"</span>))    <span class="comment"># True</span>
<span class="keyword">print</span>(is_balanced(<span class="string">"([)]"</span>))      <span class="comment"># False</span>
</code>
                </div>

                <hr style="margin: 2rem 0;">

                <h3>4. Queues</h3>
                <p>
                    FIFO (First In, First Out) data structure. Like a line at a store - first person in line gets served first.
                </p>

                <h4>Common Uses:</h4>
                <ul>
                    <li>Task scheduling</li>
                    <li>Print queue</li>
                    <li>Breadth-first search</li>
                    <li>Message queues</li>
                </ul>

                <div class="code-block" data-language="python">
<code><span class="keyword">from</span> collections <span class="keyword">import</span> deque

<span class="keyword">class</span> <span class="class-name">Queue</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.items = deque()
    
    <span class="keyword">def</span> <span class="function">enqueue</span>(self, item):
        <span class="string">"""Add item to rear - O(1)"""</span>
        self.items.append(item)
    
    <span class="keyword">def</span> <span class="function">dequeue</span>(self):
        <span class="string">"""Remove and return front item - O(1)"""</span>
        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():
            <span class="keyword">return</span> self.items.popleft()
        <span class="keyword">raise</span> <span class="class-name">IndexError</span>(<span class="string">"Queue is empty"</span>)
    
    <span class="keyword">def</span> <span class="function">front</span>(self):
        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():
            <span class="keyword">return</span> self.items[<span class="number">0</span>]
        <span class="keyword">return</span> <span class="keyword">None</span>
    
    <span class="keyword">def</span> <span class="function">is_empty</span>(self):
        <span class="keyword">return</span> <span class="keyword">len</span>(self.items) == <span class="number">0</span>

<span class="comment"># Example: Printer Queue</span>
<span class="keyword">class</span> <span class="class-name">PrintQueue</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.queue = Queue()
    
    <span class="keyword">def</span> <span class="function">add_job</span>(self, job_name):
        <span class="keyword">print</span>(<span class="string">f"Adding job: {job_name}"</span>)
        self.queue.enqueue(job_name)
    
    <span class="keyword">def</span> <span class="function">process_job</span>(self):
        <span class="keyword">if</span> <span class="keyword">not</span> self.queue.is_empty():
            job = self.queue.dequeue()
            <span class="keyword">print</span>(<span class="string">f"Printing: {job}"</span>)
        <span class="keyword">else</span>:
            <span class="keyword">print</span>(<span class="string">"No jobs in queue"</span>)

printer = PrintQueue()
printer.add_job(<span class="string">"Document1.pdf"</span>)
printer.add_job(<span class="string">"Photo.jpg"</span>)
printer.process_job()  <span class="comment"># Prints Document1.pdf</span>
printer.process_job()  <span class="comment"># Prints Photo.jpg</span>
</code>
                </div>

                <hr style="margin: 2rem 0;">

                <h3>5. Hash Tables (Dictionaries)</h3>
                <p>
                    Stores key-value pairs with O(1) average lookup time. Python dictionaries and JavaScript 
                    objects are hash tables under the hood.
                </p>

                <div class="code-block" data-language="python">
<code><span class="comment"># Python dict is a hash table</span>
phonebook = {
    <span class="string">"Alice"</span>: <span class="string">"555-1234"</span>,
    <span class="string">"Bob"</span>: <span class="string">"555-5678"</span>,
    <span class="string">"Charlie"</span>: <span class="string">"555-9012"</span>
}

<span class="comment"># O(1) lookup</span>
<span class="keyword">print</span>(phonebook[<span class="string">"Alice"</span>])  <span class="comment"># 555-1234</span>

<span class="comment"># Simple hash table implementation</span>
<span class="keyword">class</span> <span class="class-name">HashTable</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, size=<span class="number">10</span>):
        self.size = size
        self.table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="keyword">range</span>(size)]
    
    <span class="keyword">def</span> <span class="function">_hash</span>(self, key):
        <span class="string">"""Simple hash function"""</span>
        <span class="keyword">return</span> <span class="keyword">hash</span>(key) % self.size
    
    <span class="keyword">def</span> <span class="function">insert</span>(self, key, value):
        <span class="string">"""Insert key-value pair - O(1) average"""</span>
        index = self._hash(key)
        
        <span class="comment"># Check if key exists, update if found</span>
        <span class="keyword">for</span> i, (k, v) <span class="keyword">in</span> <span class="keyword">enumerate</span>(self.table[index]):
            <span class="keyword">if</span> k == key:
                self.table[index][i] = (key, value)
                <span class="keyword">return</span>
        
        <span class="comment"># Add new key-value pair</span>
        self.table[index].append((key, value))
    
    <span class="keyword">def</span> <span class="function">get</span>(self, key):
        <span class="string">"""Retrieve value by key - O(1) average"""</span>
        index = self._hash(key)
        
        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.table[index]:
            <span class="keyword">if</span> k == key:
                <span class="keyword">return</span> v
        
        <span class="keyword">raise</span> <span class="class-name">KeyError</span>(<span class="string">f"Key '{key}' not found"</span>)
    
    <span class="keyword">def</span> <span class="function">delete</span>(self, key):
        <span class="string">"""Remove key-value pair - O(1) average"""</span>
        index = self._hash(key)
        
        <span class="keyword">for</span> i, (k, v) <span class="keyword">in</span> <span class="keyword">enumerate</span>(self.table[index]):
            <span class="keyword">if</span> k == key:
                <span class="keyword">del</span> self.table[index][i]
                <span class="keyword">return</span>
        
        <span class="keyword">raise</span> <span class="class-name">KeyError</span>(<span class="string">f"Key '{key}' not found"</span>)

<span class="comment"># Usage</span>
ht = HashTable()
ht.insert(<span class="string">"apple"</span>, <span class="number">5</span>)
ht.insert(<span class="string">"banana"</span>, <span class="number">7</span>)
<span class="keyword">print</span>(ht.get(<span class="string">"apple"</span>))  <span class="comment"># 5</span>
</code>
                </div>

                <div class="info-box important">
                    <h4>‚ö†Ô∏è Hash Collisions</h4>
                    <p>
                        When two keys hash to the same index, it's called a collision. Common resolution strategies:
                    </p>
                    <ul>
                        <li><strong>Chaining</strong> - Store multiple items at same index (used above)</li>
                        <li><strong>Open Addressing</strong> - Find next available slot</li>
                        <li><strong>Double Hashing</strong> - Use second hash function</li>
                    </ul>
                </div>

                <hr style="margin: 2rem 0;">

                <h3>6. Trees</h3>
                <p>
                    Hierarchical data structure with a root node and child nodes. Each node can have zero or more children.
                </p>

                <h4>Binary Search Tree (BST)</h4>
                <p>
                    A binary tree where left child < parent < right child. Enables O(log n) search, insert, and delete.
                </p>

                <div class="code-block" data-language="python">
<code><span class="keyword">class</span> <span class="class-name">TreeNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, value):
        self.value = value
        self.left = <span class="keyword">None</span>
        self.right = <span class="keyword">None</span>

<span class="keyword">class</span> <span class="class-name">BinarySearchTree</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.root = <span class="keyword">None</span>
    
    <span class="keyword">def</span> <span class="function">insert</span>(self, value):
        <span class="string">"""Insert value - O(log n) average"""</span>
        <span class="keyword">if</span> <span class="keyword">not</span> self.root:
            self.root = TreeNode(value)
        <span class="keyword">else</span>:
            self._insert_recursive(self.root, value)
    
    <span class="keyword">def</span> <span class="function">_insert_recursive</span>(self, node, value):
        <span class="keyword">if</span> value < node.value:
            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">None</span>:
                node.left = TreeNode(value)
            <span class="keyword">else</span>:
                self._insert_recursive(node.left, value)
        <span class="keyword">else</span>:
            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">None</span>:
                node.right = TreeNode(value)
            <span class="keyword">else</span>:
                self._insert_recursive(node.right, value)
    
    <span class="keyword">def</span> <span class="function">search</span>(self, value):
        <span class="string">"""Search for value - O(log n) average"""</span>
        <span class="keyword">return</span> self._search_recursive(self.root, value)
    
    <span class="keyword">def</span> <span class="function">_search_recursive</span>(self, node, value):
        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:
            <span class="keyword">return</span> <span class="keyword">False</span>
        
        <span class="keyword">if</span> value == node.value:
            <span class="keyword">return</span> <span class="keyword">True</span>
        <span class="keyword">elif</span> value < node.value:
            <span class="keyword">return</span> self._search_recursive(node.left, value)
        <span class="keyword">else</span>:
            <span class="keyword">return</span> self._search_recursive(node.right, value)
    
    <span class="keyword">def</span> <span class="function">inorder_traversal</span>(self):
        <span class="string">"""Visit nodes in sorted order"""</span>
        result = []
        self._inorder_recursive(self.root, result)
        <span class="keyword">return</span> result
    
    <span class="keyword">def</span> <span class="function">_inorder_recursive</span>(self, node, result):
        <span class="keyword">if</span> node:
            self._inorder_recursive(node.left, result)
            result.append(node.value)
            self._inorder_recursive(node.right, result)

<span class="comment"># Usage</span>
bst = BinarySearchTree()
<span class="keyword">for</span> value <span class="keyword">in</span> [<span class="number">50</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">80</span>]:
    bst.insert(value)

<span class="keyword">print</span>(bst.search(<span class="number">40</span>))           <span class="comment"># True</span>
<span class="keyword">print</span>(bst.search(<span class="number">100</span>))          <span class="comment"># False</span>
<span class="keyword">print</span>(bst.inorder_traversal()) <span class="comment"># [20,30,40,50,60,70,80]</span>
</code>
                </div>

                <h3>Data Structure Selection Guide</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Scenario</th>
                            <th>Best Data Structure</th>
                            <th>Why</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Fast lookups by key</td>
                            <td>Hash Table</td>
                            <td>O(1) average access</td>
                        </tr>
                        <tr>
                            <td>Maintain sorted order</td>
                            <td>Binary Search Tree</td>
                            <td>O(log n) operations, sorted traversal</td>
                        </tr>
                        <tr>
                            <td>Undo functionality</td>
                            <td>Stack</td>
                            <td>LIFO behavior</td>
                        </tr>
                        <tr>
                            <td>Task scheduling</td>
                            <td>Queue</td>
                            <td>FIFO behavior</td>
                        </tr>
                        <tr>
                            <td>Frequent insertions/deletions</td>
                            <td>Linked List</td>
                            <td>O(1) insert/delete</td>
                        </tr>
                        <tr>
                            <td>Random access needed</td>
                            <td>Array/List</td>
                            <td>O(1) index access</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box tip">
                    <h4>üí° Key Takeaways</h4>
                    <ul>
                        <li>Choose data structures based on your operations, not arbitrarily</li>
                        <li>Time complexity matters more as data size grows</li>
                        <li>Space-time tradeoff: sometimes use more memory for faster operations</li>
                        <li>Most languages provide optimized built-in implementations</li>
                        <li>Understand the underlying concepts even if using built-ins</li>
                    </ul>
                </div>

                <h3>Summary</h3>
                <ul>
                    <li>Data structures organize data for efficient access and modification</li>
                    <li>Big O notation describes algorithmic efficiency</li>
                    <li>Arrays: fast access, slow insertion/deletion</li>
                    <li>Linked Lists: fast insertion/deletion, slow access</li>
                    <li>Stacks & Queues: specialized access patterns (LIFO/FIFO)</li>
                    <li>Hash Tables: O(1) average lookup time</li>
                    <li>Trees: hierarchical data, O(log n) operations</li>
                </ul>

                <h3>Next Steps</h3>
                <p>
                    In the next lesson on Algorithms, we'll explore sorting, searching, recursion, 
                    dynamic programming, and graph algorithms that work with these data structures.
                </p>
            </div>

            <div class="lesson-navigation">
                <a href="08-oop-principles.html" class="nav-btn">‚Üê Previous: OOP Principles</a>
                <a href="10-algorithms.html" class="nav-btn">Next: Algorithms ‚Üí</a>
            </div>
        </main>
    </div>

    <script src="../../../js/main.js"></script>
</body>
</html>
